// The MIT License
//
// Copyright (c) 2020 Temporal Technologies Inc.  All rights reserved.
//
// Copyright (c) 2020 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package tqid

import (
	"errors"
	"fmt"
	"strconv"
	"strings"

	enumspb "go.temporal.io/api/enums/v1"
	taskqueuepb "go.temporal.io/api/taskqueue/v1"
	"go.temporal.io/server/common/namespace"
)

const (
	// NonRootPartitionPrefix is the prefix for all mangled task queue names.
	NonRootPartitionPrefix = "/_sys/"
	PartitionDelimiter     = "/"
)

type (
	// TaskQueue represents the high-level task queue that user create by explicitly providing a TaskQueue name
	// when starting a worker or a workflow. Under the hood, a TaskQueue can be broken down to multiple sticky
	// or normal partitions.
	TaskQueue struct {
		namespaceId namespace.ID
		// this can be string as long as it does not start with /_sys/.
		name string
	}

	// Partition is a sticky or normal partition of a TaskQueue.
	// Each Partition has a distinct task queue partition manager in memory in Matching service.
	// Normal partition with `partitionId=0` is called the "root". Sticky queues are not considered root.
	Partition interface {
		NamespaceID() namespace.ID
		TaskQueue() *TaskQueue
		TaskType() enumspb.TaskQueueType
		// IsRoot always returns false for Sticky partitions
		IsRoot() bool
		IsSticky() bool
		Kind() enumspb.TaskQueueKind

		// RpcName returns the mangled name of the task queue partition, to be used in RPCs.
		//
		// RPC names look like this:
		//
		//  sticky partition:			<sticky name>
		//	root normal partition: 		<task queue name>
		//	non-root normal partition: 	/_sys/<task queue name>/<partition id>
		//
		// This scheme lets users use anything they like for a base name, except for strings
		// starting with "/_sys/", without ambiguity.
		//
		// For backward compatibility, unversioned low-level task queues with partition 0 do not
		// use mangled names, they use the bare base name.
		RpcName() string
		Key() PartitionKey
	}

	// NormalPartition a TaskQueue can have two or more normal partitions each identified by task type (activity vs
	// workflow) and a `partitionId`. The partition with ID 0 is called a root partition. Every TaskQueue always has
	// two root partitions, one for activities and one for workflows.
	NormalPartition struct {
		taskQueue   *TaskQueue
		taskType    enumspb.TaskQueueType
		partitionId int
	}

	// StickyPartition is made by SDK for a single workflow worker to keep workflow tasks of the same execution
	// in the same worker for caching benefits. Each sticky partition is identified by a unique `stickyName`
	// generated by SDK. A StickyPartition can only have workflow task type.
	StickyPartition struct {
		stickyName string
		taskQueue  *TaskQueue
	}

	// PartitionKey uniquely identifies a task queue partition, to be used in maps.
	// Note that task queue kind (sticky vs normal) and normal name for sticky task queues are not
	// part of the task queue partition identity.
	PartitionKey struct {
		namespaceID string
		name        string
		partitionId int
		taskType    enumspb.TaskQueueType
	}
)

var _ Partition = (*NormalPartition)(nil)
var _ Partition = (*StickyPartition)(nil)

var (
	ErrNoParent      = errors.New("root task queue partition has no parent")
	ErrInvalidDegree = errors.New("invalid task queue partition branching degree")
	ErrNonZeroSticky = errors.New("only sticky partitions can not have non-zero partition ID")
)

// FromBaseName takes a high-level name and returns a TaskQueue. Returns an error if name looks like a
// mangled name.
func FromBaseName(namespaceId string, name string) (*TaskQueue, error) {
	if strings.HasPrefix(name, NonRootPartitionPrefix) {
		return nil, fmt.Errorf("base name %q must not have prefix %q", name, NonRootPartitionPrefix) // nolint:goerr113
	}
	return &TaskQueue{
		namespaceId: namespace.ID(namespaceId),
		name:        name,
	}, nil
}

func FromProto(proto *taskqueuepb.TaskQueue, namespaceId string, taskType enumspb.TaskQueueType) (Partition, error) {
	baseName, partition, err := parseRpcName(proto.GetName())
	if err != nil {
		return nil, err
	}

	kind := proto.GetKind()
	normalName := proto.GetNormalName()
	if normalName != "" && kind != enumspb.TASK_QUEUE_KIND_STICKY {
		return nil, fmt.Errorf("only sticky queues can have normal name. tq: %s, normal name: %s", baseName, normalName) // nolint:goerr113
	}

	switch kind {
	case enumspb.TASK_QUEUE_KIND_STICKY:
		if partition != 0 {
			return nil, fmt.Errorf("%w. base name: %s, normal name: %s", ErrNonZeroSticky, baseName, normalName)
		}
		tq := &TaskQueue{namespace.ID(namespaceId), normalName}
		return tq.StickyPartition(baseName), nil
	default:
		tq := &TaskQueue{namespace.ID(namespaceId), baseName}
		return tq.NormalPartition(taskType, partition), nil
	}
}

func (n *TaskQueue) Name() string {
	return n.name
}

func (n *TaskQueue) NamespaceID() namespace.ID {
	return n.namespaceId
}

func (n *TaskQueue) NormalPartition(taskType enumspb.TaskQueueType, partitionId int) *NormalPartition {
	return &NormalPartition{
		taskQueue:   n,
		partitionId: partitionId,
		taskType:    taskType,
	}
}

func (n *TaskQueue) StickyPartition(stickyName string) *StickyPartition {
	return &StickyPartition{stickyName, n}
}

func (n *TaskQueue) RootPartition(taskType enumspb.TaskQueueType) *NormalPartition {
	return n.NormalPartition(taskType, 0)
}

func (n *TaskQueue) String() string {
	return fmt.Sprintf("TaskQueue(nsid:%.5s, name:%s)",
		n.NamespaceID().String(),
		n.Name(),
	)
}

func (s *StickyPartition) StickyName() string {
	return s.stickyName
}

func (s *StickyPartition) TaskType() enumspb.TaskQueueType {
	return enumspb.TASK_QUEUE_TYPE_WORKFLOW
}

func (s *StickyPartition) Kind() enumspb.TaskQueueKind {
	return enumspb.TASK_QUEUE_KIND_STICKY
}

func (s *StickyPartition) IsSticky() bool {
	return true
}

func (s *StickyPartition) NamespaceID() namespace.ID {
	return s.taskQueue.NamespaceID()
}

func (s *StickyPartition) RootPartition() Partition {
	return s
}

func (s *StickyPartition) TaskQueue() *TaskQueue {
	return s.taskQueue
}

func (s *StickyPartition) IsRoot() bool {
	return false
}

func (s *StickyPartition) RpcName() string {
	return s.stickyName
}

func (s *StickyPartition) Key() PartitionKey {
	return PartitionKey{
		namespaceID: s.NamespaceID().String(),
		name:        s.StickyName(),
		taskType:    s.TaskType(),
	}
}

func (s *StickyPartition) String() string {
	return fmt.Sprintf("StickyPartition(sticky name: %s, tq: %s)",
		s.StickyName(),
		s.taskQueue,
	)
}

func (p *NormalPartition) TaskQueue() *TaskQueue {
	return p.taskQueue
}

func (p *NormalPartition) NormalTaskQueue() *TaskQueue {
	return p.taskQueue
}

func (p *NormalPartition) IsRoot() bool {
	return p.partitionId == 0
}

func (p *NormalPartition) IsSticky() bool {
	return false
}

func (p *NormalPartition) Kind() enumspb.TaskQueueKind {
	return enumspb.TASK_QUEUE_KIND_NORMAL
}

func (p *NormalPartition) PartitionID() int {
	return p.partitionId
}

func (p *NormalPartition) NamespaceID() namespace.ID {
	return p.taskQueue.namespaceId
}

func (p *NormalPartition) TaskType() enumspb.TaskQueueType {
	return p.taskType
}

// Parent returns a NormalPartition for the parent partition, using the given branching degree.
func (p *NormalPartition) Parent(degree int) (*NormalPartition, error) {
	if p.IsRoot() {
		return nil, ErrNoParent
	} else if degree < 1 {
		return nil, ErrInvalidDegree
	}
	parent := (p.partitionId+degree-1)/degree - 1
	return p.taskQueue.NormalPartition(p.taskType, parent), nil
}

func (p *NormalPartition) RpcName() string {
	if p.IsRoot() {
		return p.TaskQueue().Name()
	}
	return fmt.Sprintf("%s%s%s%d", NonRootPartitionPrefix, p.TaskQueue().Name(), PartitionDelimiter, p.partitionId)
}

func (p *NormalPartition) Key() PartitionKey {
	return PartitionKey{
		namespaceID: p.NamespaceID().String(),
		name:        p.TaskQueue().Name(),
		partitionId: p.partitionId,
		taskType:    p.TaskType(),
	}
}

func (p *NormalPartition) String() string {
	return fmt.Sprintf("NormalPartition(prtn: %d, tq: %s)",
		p.partitionId,
		p.taskQueue,
	)
}

// ParseTaskQueuePartition takes the rpc name of a task queue partition and returns a ParseTaskQueuePartition.
// Returns an error if the given name is not a valid rpc name.
func parseRpcName(rpcName string) (string, int, error) {
	baseName := rpcName
	partition := 0

	if strings.HasPrefix(rpcName, NonRootPartitionPrefix) {
		suffixOff := strings.LastIndex(rpcName, PartitionDelimiter)
		if suffixOff <= len(NonRootPartitionPrefix) {
			return "", 0, fmt.Errorf("invalid task queue partition name %q", rpcName) // nolint:goerr113
		}
		baseName = rpcName[len(NonRootPartitionPrefix):suffixOff]
		suffix := rpcName[suffixOff+1:]

		var err error
		partition, err = strconv.Atoi(suffix)
		if err != nil || partition <= 0 {
			return "", 0, fmt.Errorf("invalid task queue partition name %q", rpcName) // nolint:goerr113
		}
	}

	if strings.HasPrefix(baseName, NonRootPartitionPrefix) {
		return "", 0, fmt.Errorf("base name %q must not have prefix %q", baseName, NonRootPartitionPrefix) // nolint:goerr113
	}
	return baseName, partition, nil
}
